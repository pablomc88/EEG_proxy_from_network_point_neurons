# -*- coding: utf-8 -*-

"""
Recurrent neural network as described in [1] with conductance-based synapses. External
inputs to each cell are assumed to arise from 1600 external synapses of the AMPA type
(800 are from thalamocortical afferents, and 800 are from cortical-cortical afferents).

[1] Cavallari, S., Panzeri, S., & Mazzoni, A. (2014). Comparison of the dynamics
of neural interactions between current-based and conductance-based integrate-and-fire
recurrent networks. Frontiers in neural circuits, 8, 12.
"""

import nest
import nest.topology as tp
import matplotlib.pyplot as plt
import numpy as np
import time
import sys,os

sys.path.append(os.path.join(os.path.dirname(__file__), '/analysis'))
import tools

class network(object):

    def __init__(self,Network_params, Neuron_params, Simulation_params,
                External_input_params, Analysis_params):

        #! ===========
        #! Parameters
        #! ===========

        # Parameters of the network
        self.N_exc = Network_params['N_exc'] # number of excitatory neurons
        self.N_inh = Network_params['N_inh'] # number of inhibitory neurons
        self.P = Network_params['P'] # probability of connection
        self.extent = Network_params['extent'] # Spatial extent of the network (mm)
        # Synaptic conductances
        self.exc_exc_recurrent = Network_params["exc_exc_recurrent"] # nS
        self.exc_inh_recurrent = Network_params["exc_inh_recurrent"] # nS
        self.inh_inh_recurrent = Network_params["inh_inh_recurrent"] # nS
        self.inh_exc_recurrent = Network_params["inh_exc_recurrent"] # nS
        self.th_exc_external = Network_params["th_exc_external"] # nS
        self.th_inh_external = Network_params["th_inh_external"] # nS
        self.cc_exc_external = Network_params["cc_exc_external"] # nS
        self.cc_inh_external = Network_params["cc_inh_external"] # nS

        # Parameters of the neuron models
        self.excitatory_cell_params  = {
          "V_th": Neuron_params[0]["V_th"],       # mV
          "V_reset": Neuron_params[0]["V_reset"],    # mV
          "t_ref": Neuron_params[0]["t_ref"],        # ms
          "g_L": Neuron_params[0]["g_L"],      # nS
          "C_m": Neuron_params[0]["C_m"],        # pF
          "E_ex": Neuron_params[0]["E_ex"],         # mV
          "E_in": Neuron_params[0]["E_in"],       # mV
          "E_L": Neuron_params[0]["E_L"],        # mV
          "tau_rise_AMPA": Neuron_params[0]["tau_rise_AMPA"],  # ms
          "tau_decay_AMPA": Neuron_params[0]["tau_decay_AMPA"], # ms
          "tau_rise_GABA_A": Neuron_params[0]["tau_rise_GABA_A"],  # ms
          "tau_decay_GABA_A": Neuron_params[0]["tau_decay_GABA_A"], # ms
          "tau_m": Neuron_params[0]["tau_m"],  # ms
          "I_e": Neuron_params[0]["I_e"] # pA
        }

        self.inhibitory_cell_params  = {
          "V_th": Neuron_params[1]["V_th"],       # mV
          "V_reset": Neuron_params[1]["V_reset"],    # mV
          "t_ref": Neuron_params[1]["t_ref"],        # ms
          "g_L": Neuron_params[1]["g_L"],      # nS
          "C_m": Neuron_params[1]["C_m"],        # pF
          "E_ex": Neuron_params[1]["E_ex"],         # mV
          "E_in": Neuron_params[1]["E_in"],       # mV
          "E_L": Neuron_params[1]["E_L"],        # mV
          "tau_rise_AMPA": Neuron_params[1]["tau_rise_AMPA"],  # ms
          "tau_decay_AMPA": Neuron_params[1]["tau_decay_AMPA"], # ms
          "tau_rise_GABA_A": Neuron_params[1]["tau_rise_GABA_A"],  # ms
          "tau_decay_GABA_A": Neuron_params[1]["tau_decay_GABA_A"], # ms
          "tau_m": Neuron_params[1]["tau_m"],  # ms
          "I_e": Neuron_params[1]["I_e"] # pA
        }

        # Parameters of the simulation
        self.simtime = Simulation_params["simtime"] # ms
        self.simstep = Simulation_params["simstep"] # ms
        self.num_threads = Simulation_params["num_threads"] # Number of threads
        self.toMemory = Simulation_params["toMemory"] # True = record to memory,
                                                        # False = to file

        # The external input generated by a Poisson process with rate:
        # v_ext(t) = v_signal(t) + n(t),
        # v_signal(t) = A * sin (2 * pi * f *t) + v_0,
        # n(t) is generated by an Ornstein-Uhlenbeck process
        self.v_0 = External_input_params["v_0"] # constant rate
        self.A_ext = External_input_params["A_ext"] # Amplitude (spikes/ms)
        self.f_ext = External_input_params["f_ext"] # Frequency (Hz)
        self.OU_sigma = External_input_params["OU_sigma"] # Standard deviation of n(t) (spike/ms)
        self.OU_tau = External_input_params["OU_tau"]  # Time constant of n(t) (ms)

        # Parameters for the analysis of results
        self.To_be_measured = Analysis_params["To_be_measured"] # Array with
        # properties of the subthreshold response that will be recorded among
        # 'V_m', 'g_ex','g_in'.
        self.Compute_PSP = Analysis_params["Compute_PSP"] # True/False
        self.PSP_number_cells = Analysis_params["PSP_number_cells"] # Number of cells
                                                        # used to compute the PSP
        self.cells_to_analyze = Analysis_params["cells_to_analyze"] # Selected cells

    def create_network(self):

        #! =============================
        #! Configuration of the network
        #! =============================

        # Load the LIF neuron model
        model = nest.Models(mtype='nodes',sel='iaf_bw_2003')
        if not model:
            nest.Install("mymodule")

        # Layers are configured as free layers (no spatial structure)
        pos_exc = [[np.random.uniform(-self.extent/2.0,self.extent/2.0),
                    np.random.uniform(-self.extent/2.0,self.extent/2.0)]
                    for j in range(self.N_exc)]
        layerProps_exc = {
            'positions': pos_exc,
            'extent'   : [self.extent, self.extent],
            'edge_wrap': False
            }

        pos_inh = [[np.random.uniform(-self.extent/2.0,self.extent/2.0),
                    np.random.uniform(-self.extent/2.0,self.extent/2.0)]
                    for j in range(self.N_inh)]
        layerProps_inh = {
            'positions': pos_inh,
            'extent'   : [self.extent, self.extent],
            'edge_wrap': False
            }

        # Layers of thalamocortical and cortical-cortical inputs have a single
        # poisson generator that sends independent spike trains to each cell,
        # instead of a layer with multiple poisson generators (to decrease
        # memory consumption)
        pos_th = [[np.random.uniform(-self.extent/2.0,self.extent/2.0),
                    np.random.uniform(-self.extent/2.0,self.extent/2.0)]
                    for j in range(1)]
        layerProps_th = {
            'positions': pos_th,
            'extent'   : [self.extent, self.extent],
            'edge_wrap': False
            }

        pos_cc = [[np.random.uniform(-self.extent/2.0,self.extent/2.0),
                    np.random.uniform(-self.extent/2.0,self.extent/2.0)]
                    for j in range(1)]
        layerProps_cc = {
            'positions': pos_cc,
            'extent'   : [self.extent, self.extent],
            'edge_wrap': False
            }

        # There is one parrot neuron for each excitatory/inhibitory cell of the network
        pos_parrot = [[np.random.uniform(-self.extent/2.0,self.extent/2.0),
                        np.random.uniform(-self.extent/2.0,self.extent/2.0)]
                        for j in range(self.N_exc + self.N_inh)]
        layerProps_parrot = {
            'positions': pos_parrot,
            'extent'   : [self.extent, self.extent],
            'edge_wrap': False
            }

        # NEST Kernel and Network settings
        np.random.seed(int(time.time()))
        seeds = np.arange(self.num_threads) + int((time.time()*100)%2**32) # Seeds
                                        # are different in each simulation
        nest.ResetKernel()
        nest.ResetNetwork()
        nest.SetKernelStatus({"local_num_threads": self.num_threads,
                              "resolution": self.simstep,
                              "data_path": os.path.abspath(os.path.join(__file__ ,"../results")),
                              "rng_seeds": list(seeds)})

        # Define properties of neuron models
        nest.CopyModel("iaf_bw_2003", "exc_cell", self.excitatory_cell_params)
        nest.CopyModel("iaf_bw_2003", "inh_cell", self.inhibitory_cell_params)

        # Thalamocortical and cortical-cortical inputs are defined as poisson generators
        nest.CopyModel("inhomogeneous_poisson_generator", "thalamocortical_input")
        nest.CopyModel("inhomogeneous_poisson_generator", "cortical_input")

        # Create layers
        self.exc = tp.CreateLayer(tools.updateDicts(layerProps_exc, {'elements': 'exc_cell'}))
        self.inh = tp.CreateLayer(tools.updateDicts(layerProps_inh, {'elements': 'inh_cell'}))
        self.thalamo = tp.CreateLayer(tools.updateDicts(layerProps_th,
                                {'elements': 'thalamocortical_input'}))
        self.cort = tp.CreateLayer(tools.updateDicts(layerProps_cc,
                                {'elements': 'cortical_input'}))
        # The layers of parrot neurons are used to compute the PSP (see below).
        # They also facilitate the computation of spike times from external inputs
        self.parrot_layer_th = tp.CreateLayer(tools.updateDicts(layerProps_parrot,
                                {'elements': 'parrot_neuron'}))
        self.parrot_layer_cc = tp.CreateLayer(tools.updateDicts(layerProps_parrot,
                                {'elements': 'parrot_neuron'}))

        # Ornstein-Uhlenbeck process (solved by Euler method)
        time_array = np.arange(self.simstep,self.simtime-
        self.simstep,self.simstep)
        OU_n = len(time_array)  # Number of time steps.
        # Define renormalized variables (to avoid recomputing these constants
        # at every time step)
        OU_sigma_bis = self.OU_sigma * np.sqrt(2. / self.OU_tau)
        OU_sqrtdt = np.sqrt(self.simstep)
        OU_x = np.zeros(OU_n) # OU output

        for i in range(OU_n - 1):
            OU_x[i + 1] = OU_x[i] + self.simstep * (-OU_x[i]  / self.OU_tau) + \
                OU_sigma_bis * OU_sqrtdt * np.random.randn()

        # Sinusoidal rate
        v_signal = self.A_ext * np.sin(2.0 * np.pi * self.f_ext *
         time_array/1000.0) + self.v_0

        # Final rate of the Poisson generators
        for n in nest.GetLeaves(self.thalamo)[0]:
            nest.SetStatus([n],{'rate_times' : time_array,
            'rate_values':v_signal})

        for n in nest.GetLeaves(self.cort)[0]:
            nest.SetStatus([n],{'rate_times' : time_array,
            'rate_values':OU_x})

        # Recurrent connections
        # (the size of the mask is big enough to ensure all cells are included within it)
        dict_exc_exc_recurrent = {
            "connection_type":"convergent",
            "mask": {'rectangular': {'lower_left':[-self.extent,-self.extent],
                                    'upper_right':[self.extent,self.extent]}},
            "kernel": self.P,
            "synapse_model": 'static_synapse',
            "weights": self.exc_exc_recurrent,
            "sources": {"model": 'exc_cell'},
            "targets": {"model": 'exc_cell'},
            "allow_autapses":False,
            "allow_multapses":False
        }

        dict_exc_inh_recurrent = {
            "connection_type":"convergent",
            "mask": {'rectangular': {'lower_left':[-self.extent,-self.extent],
                                    'upper_right':[self.extent,self.extent]}},
            "kernel": self.P,
            "synapse_model": 'static_synapse',
            "weights": self.exc_inh_recurrent,
            "sources": {"model": 'exc_cell'},
            "targets": {"model": 'inh_cell'},
            "allow_autapses":False,
            "allow_multapses":False
        }

        dict_inh_inh_recurrent = {
            "connection_type":"convergent",
            "mask": {'rectangular': {'lower_left':[-self.extent,-self.extent],
                                    'upper_right':[self.extent,self.extent]}},
            "kernel": self.P,
            "synapse_model": 'static_synapse',
            "weights": self.inh_inh_recurrent,
            "sources": {"model": 'inh_cell'},
            "targets": {"model": 'inh_cell'},
            "allow_autapses":False,
            "allow_multapses":False
        }

        dict_inh_exc_recurrent = {
            "connection_type":"convergent",
            "mask": {'rectangular': {'lower_left':[-self.extent,-self.extent],
                                    'upper_right':[self.extent,self.extent]}},
            "kernel": self.P,
            "synapse_model": 'static_synapse',
            "weights": self.inh_exc_recurrent,
            "sources": {"model": 'inh_cell'},
            "targets": {"model": 'exc_cell'},
            "allow_autapses":False,
            "allow_multapses":False
        }

        tp.ConnectLayers(self.exc,self.exc,dict_exc_exc_recurrent)
        tp.ConnectLayers(self.exc,self.inh,dict_exc_inh_recurrent)
        tp.ConnectLayers(self.inh,self.inh,dict_inh_inh_recurrent)
        tp.ConnectLayers(self.inh,self.exc,dict_inh_exc_recurrent)

        # Connections of the external inputs: each cell receives the same number of
        # external inputs as recurrent excitatory inputs (800 for the 5000-neuron network)
        dict_th_parrot = {
            "connection_type":"convergent",
            "mask": {'rectangular': {'lower_left':[-self.extent,-self.extent],
                                    'upper_right':[self.extent,self.extent]}},
            "kernel": 1.,
            "synapse_model": 'static_synapse',
            "number_of_connections": 800, # constant fan in
            "weights": 1.0,
            "sources": {"model": 'thalamocortical_input'},
            "targets": {"model": 'parrot_neuron'},
            "allow_autapses":False,
            "allow_multapses":True
        }

        dict_cc_parrot = {
            "connection_type":"convergent",
            "mask": {'rectangular': {'lower_left':[-self.extent,-self.extent],
                                    'upper_right':[self.extent,self.extent]}},
            "kernel": 1.,
            "synapse_model": 'static_synapse',
            "number_of_connections": 800, # constant fan in
            "weights": 1.0,
            "sources": {"model": 'cortical_input'},
            "targets": {"model": 'parrot_neuron'},
            "allow_autapses":False,
            "allow_multapses":True
        }

        # A parrot neuron is necessary to send the same spike train to both
        # original cells and cloned cells (used to compute the PSP).

        # Connection of Poisson generators with parrot neurons
        tp.ConnectLayers(self.thalamo,self.parrot_layer_th,dict_th_parrot)
        tp.ConnectLayers(self.cort,self.parrot_layer_cc,dict_cc_parrot)

        parrot_n_th = nest.GetLeaves(self.parrot_layer_th)[0]
        parrot_n_cc = nest.GetLeaves(self.parrot_layer_cc)[0]

        # Connection of parrot neurons with excitatory/inhibitory neurons
        i = 0
        for n in nest.GetLeaves(self.exc)[0]:
            nest.Connect([parrot_n_th[i]],[n],
                'one_to_one',syn_spec={"model":"static_synapse",
                "weight":self.th_exc_external})
            nest.Connect([parrot_n_cc[i]],[n],
                'one_to_one',syn_spec={"model":"static_synapse",
                "weight":self.cc_exc_external})
            i+=1

        for n in nest.GetLeaves(self.inh)[0]:
            nest.Connect([parrot_n_th[i]],[n],
                'one_to_one',syn_spec={"model":"static_synapse",
                "weight":self.th_inh_external})
            nest.Connect([parrot_n_cc[i]],[n],
                'one_to_one',syn_spec={"model":"static_synapse",
                "weight":self.cc_inh_external})
            i+=1

        #! =================
        #! Checkpoint
        #! =================

        # # Plot mask and kernel of connections
        # fig = tp.PlotLayer(self.exc,nodesize =80)
        # ctr = tp.FindCenterElement(self.exc)
        #
        # tp.PlotTargets(ctr, self.exc, fig = fig,
        # mask=dict_exc_exc_recurrent['mask'], kernel=dict_exc_exc_recurrent['kernel'] ,
        # src_size =250 , tgt_color = 'red' , tgt_size =20 ,
        # kernel_color = 'green' )
        #
        # plt.show()

        # # Print the avg. number of input connections
        # pop_ex = nest.GetLeaves(self.exc)[0]
        # pop_in = nest.GetLeaves(self.inh)[0]
        # pop_parrot_th = nest.GetLeaves(self.parrot_layer_th)[0]
        # pop_parrot_cc = nest.GetLeaves(self.parrot_layer_cc)[0]
        # pop_thalamo = nest.GetLeaves(self.thalamo)[0]
        # pop_cc = nest.GetLeaves(self.cort)[0]
        #
        # number_of_connections = [0,0,0,0]
        # for k in range(100):
        #     conns_ex = nest.GetConnections(target = [pop_ex[k]])
        #     conns_th = nest.GetConnections(target = [pop_parrot_th[k]])
        #     conns_cc = nest.GetConnections(target = [pop_parrot_cc[k]])
        #
        #     st_ex = nest.GetStatus(conns_ex)
        #     st_th = nest.GetStatus(conns_th)
        #     st_cc = nest.GetStatus(conns_cc)
        #
        #     for st_con in st_ex:
        #         if st_con["source"] >= pop_ex[0] and st_con["source"] <= pop_ex[-1]:
        #             number_of_connections[0]+=1
        #         if st_con["source"] >= pop_in[0] and st_con["source"] <= pop_in[-1]:
        #             number_of_connections[1]+=1
        #
        #     for st_con in st_th:
        #         if st_con["source"] >= pop_thalamo[0] and st_con["source"] <= pop_thalamo[-1]:
        #             number_of_connections[2]+=1
        #
        #     for st_con in st_cc:
        #         if st_con["source"] >= pop_cc[0] and st_con["source"] <= pop_cc[-1]:
        #             number_of_connections[3]+=1
        #
        # print("\nExc: %s, Inh: %s, Thalamo: %s, Cort: %s\n" % (number_of_connections[0]/\
        # 100.,number_of_connections[1]/100.,number_of_connections[2]/100.,
        # number_of_connections[3]/100.))

        #! =================================================
        #! Computation of the average postsynaptic potential
        #! =================================================

        # Make a copy of a subset of neurons that receive same the synaptic input of
        # the original ones. The cloned neurons receive an extra spike, from the synapse under
        # investigation, each 100 ms

        if self.Compute_PSP:

            spike_gen_cloned = nest.Create("spike_generator")
            nest.SetStatus(spike_gen_cloned,{"spike_times":np.arange(500.0,self.simtime,100.0)})

            cloned_n_AMPA = nest.Create("exc_cell",self.PSP_number_cells)
            cloned_n_GABA = nest.Create("exc_cell",self.PSP_number_cells)

            j=0
            for n in nest.GetLeaves(self.exc)[0]:
                if j < self.PSP_number_cells:
                    conns = nest.GetConnections(target = [n])
                    st = nest.GetStatus(conns)
                    for st_con in st:
                        conn_dict = {'rule': 'one_to_one'}
                        syn_dict = {'weight': st_con["weight"]}
                        nest.Connect([st_con["source"]],[cloned_n_AMPA[j]],
                                    conn_dict, syn_dict)
                        nest.Connect([st_con["source"]],[cloned_n_GABA[j]],
                                    conn_dict, syn_dict)
                    # extra spike
                    nest.Connect(spike_gen_cloned,[cloned_n_AMPA[j]],conn_dict,
                                {'weight': self.exc_exc_recurrent})
                    nest.Connect(spike_gen_cloned,[cloned_n_GABA[j]],conn_dict,
                                {'weight': self.inh_exc_recurrent})
                    j+=1

        #! =================
        #! Recording devices
        #! =================

        # Membrane potential and conductances
        if self.toMemory:
            record_to = 'memory'
        else:
            record_to = 'file'

        if len(self.To_be_measured)>0:
            nest.CopyModel('multimeter', 'RecordingNode',
                    {'interval'   : self.simstep,
                    'record_from': self.To_be_measured,
                    'record_to'  : [record_to],
                    'withgid'    : True,
                    'withtime'   : True})

        # Spikes
        nest.CopyModel('spike_detector', 'SpikesRecorder',
                {'record_to'  : [record_to],
                'withgid'    : True,
                'withtime'   : True})

        #! =================
        #! NEST simulation
        #! =================

    def simulate_network(self,interval):

        #! =================
        #! Recording devices
        #! =================

        # Membrane potential and conductances
        if len(self.To_be_measured)>0:

            self.subthreshold_recorders = []

            # Exc
            rec_exc = nest.Create('RecordingNode')
            tgts = [nd for nd in nest.GetLeaves(self.exc)[0]]
            nest.Connect(rec_exc,tgts)
            self.subthreshold_recorders.append(rec_exc)

            # Inh
            rec_inh = nest.Create('RecordingNode')
            tgts = [nd for nd in nest.GetLeaves(self.inh)[0]]
            nest.Connect(rec_inh,tgts)
            self.subthreshold_recorders.append(rec_inh)

            # Cloned neurons
            if self.Compute_PSP:
                rec_cloned_AMPA = nest.Create('RecordingNode')
                tgts = [nd for nd in cloned_n_AMPA]
                nest.Connect(rec_cloned_AMPA,tgts)
                self.subthreshold_recorders.append(rec_cloned_AMPA)

                rec_cloned_GABA = nest.Create('RecordingNode')
                tgts = [nd for nd in cloned_n_GABA]
                nest.Connect(rec_cloned_GABA,tgts)
                self.subthreshold_recorders.append(rec_cloned_GABA)

        # Spikes
        self.spikes = []

        # For raster plots of spikes
        self.mult_exc = nest.Create('spike_detector',1)
        self.mult_inh = nest.Create('spike_detector',1)
        if self.Compute_PSP:
            mult_cloned_AMPA = nest.Create('spike_detector',1)
            mult_cloned_GABA = nest.Create('spike_detector',1)

        # Exc
        sp_exc = nest.Create('SpikesRecorder')
        tgts = [nd for nd in nest.GetLeaves(self.exc)[0]]
        nest.Connect(tgts,sp_exc)
        self.spikes.append(sp_exc)
        nest.Connect([tgts[i] for i in self.cells_to_analyze],self.mult_exc)

        # Inh
        sp_inh = nest.Create('SpikesRecorder')
        tgts = [nd for nd in nest.GetLeaves(self.inh)[0]]
        nest.Connect(tgts,sp_inh)
        self.spikes.append(sp_inh)
        nest.Connect([tgts[i] for i in self.cells_to_analyze],self.mult_inh)

        # Cloned neurons
        if self.Compute_PSP:
            sp_cloned_AMPA = nest.Create('SpikesRecorder')
            tgts = [nd for nd in cloned_n_AMPA]
            nest.Connect(tgts,sp_cloned_AMPA)
            self.spikes.append(sp_cloned_AMPA)
            nest.Connect([tgts[i] for i in range(self.PSP_number_cells)],mult_cloned_AMPA)

            sp_cloned_GABA = nest.Create('SpikesRecorder')
            tgts = [nd for nd in cloned_n_GABA]
            nest.Connect(tgts,sp_cloned_GABA)
            self.spikes.append(sp_cloned_GABA)
            nest.Connect([tgts[i] for i in range(self.PSP_number_cells)],mult_cloned_GABA)

        # Thalamocortical input
        sp_th = nest.Create('SpikesRecorder')
        tgts = [nd for nd in nest.GetLeaves(self.parrot_layer_th)[0]]
        nest.Connect(tgts,sp_th)
        self.spikes.append(sp_th)

        # Cortical-cortical_input
        sp_cc = nest.Create('SpikesRecorder')
        tgts = [nd for nd in nest.GetLeaves(self.parrot_layer_cc)[0]]
        nest.Connect(tgts,sp_cc)
        self.spikes.append(sp_cc)

        print ("\n--- Simulation ---\n")
        nest.SetStatus([0],{'print_time': True})
        nest.Simulate(interval)

        #! =================
        #! Gather results
        #! =================

        if self.Compute_PSP:
            n_rec = 4
        else:
            n_rec = 2

        data_v=[]
        for i in range(n_rec):
            if len(self.To_be_measured)>0:
                data_v.append(nest.GetStatus(self.subthreshold_recorders[i],keys='events'))
            else:
                data_v.append([])

        data_s=[]
        for i in range(n_rec+2):
            data_s.append(nest.GetStatus(self.spikes[i],keys='events'))

        senders_v = []
        for i in range(n_rec):
            if len(self.To_be_measured)>0:
                senders_v.append(data_v[i][0]['senders'])
            else:
                senders_v.append([])

        senders_s = []
        for i in range(n_rec+2):
            senders_s.append(data_s[i][0]['senders'])

        pop_ex = nest.GetLeaves(self.exc)[0]
        pop_in = nest.GetLeaves(self.inh)[0]
        pop_parrot_th = nest.GetLeaves(self.parrot_layer_th)[0]
        pop_parrot_cc = nest.GetLeaves(self.parrot_layer_cc)[0]
        pop_thalamo = nest.GetLeaves(self.thalamo)[0]
        pop_cc = nest.GetLeaves(self.cort)[0]

        if self.Compute_PSP:
            pop_cloned_AMPA = [nd for nd in cloned_n_AMPA]
            pop_cloned_GABA = [nd for nd in cloned_n_GABA]

            return [self.simtime,data_v,data_s,senders_v,senders_s,pop_ex,pop_in,
            pop_thalamo,pop_cc,pop_parrot_th,pop_parrot_cc,pop_cloned_AMPA,
            pop_cloned_GABA,self.mult_exc,self.mult_inh,mult_cloned_AMPA,mult_cloned_GABA]

        else:
            return [self.simtime,data_v,data_s,senders_v,senders_s,
            pop_ex,pop_in,pop_thalamo,pop_cc,pop_parrot_th,pop_parrot_cc,
            self.mult_exc,self.mult_inh]
